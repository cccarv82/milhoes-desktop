package ai

import (
	"bytes"
	"encoding/json"
	"fmt"
	"lottery-optimizer-gui/internal/config"
	"lottery-optimizer-gui/internal/logs"
	"lottery-optimizer-gui/internal/lottery"
	"net/http"
	"sort"
	"strings"
	"time"
)

// ClaudeClient cliente para API do Claude
type ClaudeClient struct {
	apiKey     string
	baseURL    string
	model      string
	maxTokens  int
	httpClient *http.Client
}

// ClaudeRequest estrutura da requisi√ß√£o para Claude
type ClaudeRequest struct {
	Model     string    `json:"model"`
	MaxTokens int       `json:"max_tokens"`
	Messages  []Message `json:"messages"`
}

// Message mensagem para Claude
type Message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// ClaudeResponse resposta da API do Claude
type ClaudeResponse struct {
	Content []Content `json:"content"`
	Usage   Usage     `json:"usage"`
}

// Content conte√∫do da resposta
type Content struct {
	Type string `json:"type"`
	Text string `json:"text"`
}

// Usage uso de tokens
type Usage struct {
	InputTokens  int `json:"input_tokens"`
	OutputTokens int `json:"output_tokens"`
}

// NewClaudeClient cria um novo cliente para Claude
func NewClaudeClient() *ClaudeClient {
	return &ClaudeClient{
		apiKey:    config.GetClaudeAPIKey(),
		baseURL:   "https://api.anthropic.com/v1/messages",
		model:     config.GetClaudeModel(),
		maxTokens: config.GetMaxTokens(),
		httpClient: &http.Client{
			Timeout: time.Duration(config.GlobalConfig.Claude.TimeoutSec) * time.Second,
		},
	}
}

// NewClaudeClientWithConfig cria um cliente Claude com configura√ß√µes espec√≠ficas
func NewClaudeClientWithConfig(apiKey, model string, maxTokens, timeoutSec int) *ClaudeClient {
	return &ClaudeClient{
		apiKey:    apiKey,
		baseURL:   "https://api.anthropic.com/v1/messages",
		model:     model,
		maxTokens: maxTokens,
		httpClient: &http.Client{
			Timeout: time.Duration(timeoutSec) * time.Second,
		},
	}
}

// AnalyzeStrategy usa Claude para analisar dados e gerar estrat√©gia
func (c *ClaudeClient) AnalyzeStrategy(request lottery.AnalysisRequest) (*lottery.AnalysisResponse, error) {
	// Logs especializados de IA
	logs.LogAI("üîç Iniciando AnalyzeStrategy...")
	logs.LogAI("üîç API Key length: %d", len(c.apiKey))

	if c.apiKey != "" {
		logs.LogAI("üîç API Key prefix: %s", c.apiKey[:min(10, len(c.apiKey))])
	} else {
		logs.LogError(logs.CategoryAI, "API Key VAZIA! ‚ùå")
		return nil, fmt.Errorf("chave da API do Claude n√£o configurada")
	}

	logs.LogAI("üîç Model: %s", c.model)
	logs.LogAI("üîç MaxTokens: %d", c.maxTokens)
	logs.LogAI("üîç BaseURL: %s", c.baseURL)

	prompt := c.buildAnalysisPrompt(request)

	claudeReq := ClaudeRequest{
		Model:     c.model,
		MaxTokens: c.maxTokens,
		Messages: []Message{
			{
				Role:    "user",
				Content: prompt,
			},
		},
	}

	reqBody, err := json.Marshal(claudeReq)
	if err != nil {
		logs.LogError(logs.CategoryAI, "Erro ao serializar requisi√ß√£o: %v", err)
		return nil, fmt.Errorf("erro ao serializar requisi√ß√£o: %w", err)
	}

	logs.LogAI("üîç Request body preparado. Size: %d bytes", len(reqBody))

	// Implementar retry logic com exponential backoff
	var resp *http.Response
	maxRetries := 3
	baseDelay := 2 * time.Second

	for attempt := 0; attempt < maxRetries; attempt++ {
		req, err := http.NewRequest("POST", c.baseURL, bytes.NewBuffer(reqBody))
		if err != nil {
			logs.LogError(logs.CategoryAI, "Erro ao criar requisi√ß√£o: %v", err)
			return nil, fmt.Errorf("erro ao criar requisi√ß√£o: %w", err)
		}

		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("x-api-key", c.apiKey)
		req.Header.Set("anthropic-version", "2023-06-01")

		resp, err = c.httpClient.Do(req)
		if err != nil {
			if attempt < maxRetries-1 {
				delay := baseDelay * time.Duration(1<<attempt) // Exponential backoff
				if config.IsVerbose() {
					logs.LogAI("‚ö†Ô∏è Tentativa %d falhou, tentando novamente em %v...", attempt+1, delay)
				}
				time.Sleep(delay)
				continue
			}
			logs.LogError(logs.CategoryAI, "Erro na requisi√ß√£o ap√≥s %d tentativas: %v", maxRetries, err)
			return nil, fmt.Errorf("erro na requisi√ß√£o ap√≥s %d tentativas: %w", maxRetries, err)
		}
		break
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		logs.LogError(logs.CategoryAI, "API retornou status %d", resp.StatusCode)
		return nil, fmt.Errorf("API retornou status %d", resp.StatusCode)
	}

	var claudeResp ClaudeResponse
	if err := json.NewDecoder(resp.Body).Decode(&claudeResp); err != nil {
		logs.LogError(logs.CategoryAI, "Erro ao decodificar resposta: %v", err)
		return nil, fmt.Errorf("erro ao decodificar resposta: %w", err)
	}

	if len(claudeResp.Content) == 0 {
		logs.LogError(logs.CategoryAI, "Resposta vazia do Claude")
		return nil, fmt.Errorf("resposta vazia do Claude")
	}

	// Extrair JSON limpo da resposta
	rawResponse := claudeResp.Content[0].Text
	jsonContent := extractJSON(rawResponse)

	// Enhanced debug logging
	if config.IsVerbose() {
		logs.LogAI("ü§ñ Resposta COMPLETA do Claude: %s", rawResponse)
		logs.LogAI("üîç JSON extra√≠do: %s", jsonContent)
	} else {
		logs.LogAI("ü§ñ Resposta do Claude: %s", rawResponse[:min(200, len(rawResponse))]+"...")
		logs.LogAI("üîç JSON extra√≠do: %s", jsonContent[:min(200, len(jsonContent))]+"...")
	}

	// Parsear a resposta JSON do Claude
	var analysisResp lottery.AnalysisResponse
	if err := json.Unmarshal([]byte(jsonContent), &analysisResp); err != nil {
		logs.LogError(logs.CategoryAI, "‚ùå Erro ao fazer parse do JSON: %v", err)
		logs.LogAI("üìÑ JSON que falhou: %s", jsonContent)

		// Tentar identificar o problema espec√≠fico no JSON
		if strings.Contains(err.Error(), "invalid character") {
			logs.LogAI("üîç Problema: JSON cont√©m caracteres inv√°lidos")
		} else if strings.Contains(err.Error(), "unexpected end") {
			logs.LogAI("üîç Problema: JSON incompleto ou cortado")
		} else if strings.Contains(err.Error(), "cannot unmarshal") {
			logs.LogAI("üîç Problema: Estrutura JSON n√£o corresponde ao esperado")
		}

		// Verificar se o JSON extra√≠do est√° vazio ou muito pequeno
		if len(strings.TrimSpace(jsonContent)) < 50 {
			logs.LogAI("‚ö†Ô∏è JSON extra√≠do muito pequeno: '%s'", jsonContent)
			logs.LogAI("üìÑ Resposta completa do Claude: %s", rawResponse)
		}

		// SEM FALLBACK! Retornar erro para o usu√°rio tentar novamente
		return nil, fmt.Errorf("erro no parsing da resposta do Claude - JSON inv√°lido: %v", err)
	} else {
		// CORRE√á√ÉO AUTOM√ÅTICA DE TIPOS DE LOTERIA INCORRETOS
		for i := range analysisResp.Strategy.Games {
			game := &analysisResp.Strategy.Games[i]

			// Converter tipos incorretos que o Claude possa retornar
			switch string(game.Type) {
			case "mega-sena", "megasena", "Mega-Sena", "MEGASENA":
				game.Type = lottery.MegaSena
				logs.LogAI("üîß CORRIGINDO TIPO: '%s' -> 'megasena'", string(game.Type))
			case "loto-facil", "lotofacil", "Lotof√°cil", "LOTOFACIL":
				game.Type = lottery.Lotofacil
				logs.LogAI("üîß CORRIGINDO TIPO: '%s' -> 'lotofacil'", string(game.Type))
			}
		}

		// VALIDA√á√ÉO CR√çTICA DE CUSTOS - Corrigir custos incorretos do Claude
		totalCostRecalculated := 0.0
		for i := range analysisResp.Strategy.Games {
			game := &analysisResp.Strategy.Games[i]
			correctCost := lottery.CalculateGameCost(game.Type, len(game.Numbers))

			if game.Cost != correctCost {
				logs.LogAI("üîß CORRIGINDO CUSTO: %s com %d n√∫meros - Claude retornou R$ %.2f, correto √© R$ %.2f",
					game.Type, len(game.Numbers), game.Cost, correctCost)
				game.Cost = correctCost
			}
			totalCostRecalculated += game.Cost
		}

		// Atualizar custo total se necess√°rio
		if analysisResp.Strategy.TotalCost != totalCostRecalculated {
			logs.LogAI("üîß CORRIGINDO CUSTO TOTAL: Claude retornou R$ %.2f, correto √© R$ %.2f",
				analysisResp.Strategy.TotalCost, totalCostRecalculated)
			analysisResp.Strategy.TotalCost = totalCostRecalculated
		}

		// VALIDA√á√ÉO CR√çTICA DE PRIORIZA√á√ÉO LOTOF√ÅCIL
		megaCount := 0
		lotoCount := 0
		megaCost := 0.0
		lotoCost := 0.0

		for _, game := range analysisResp.Strategy.Games {
			if game.Type == lottery.MegaSena {
				megaCount++
				megaCost += game.Cost
			} else if game.Type == lottery.Lotofacil {
				lotoCount++
				lotoCost += game.Cost
			}
		}

		// Verificar se est√° priorizando Lotof√°cil corretamente
		if megaCount > lotoCount && lotoCount > 0 {
			logs.LogAI("‚ö†Ô∏è ESTRAT√âGIA INCORRETA: %d jogos Mega-Sena vs %d Lotof√°cil - CORRIGINDO!", megaCount, lotoCount)

			// Remover jogos de Mega-Sena em excesso, mantendo apenas 1-2
			correctedGames := []lottery.Game{}
			megaAdded := 0
			maxMegaGames := 1
			if request.Preferences.Budget > 150 {
				maxMegaGames = 2
			}

			// Adicionar todos os jogos de Lotof√°cil primeiro
			for _, game := range analysisResp.Strategy.Games {
				if game.Type == lottery.Lotofacil {
					correctedGames = append(correctedGames, game)
				}
			}

			// Adicionar apenas alguns jogos de Mega-Sena
			for _, game := range analysisResp.Strategy.Games {
				if game.Type == lottery.MegaSena && megaAdded < maxMegaGames {
					correctedGames = append(correctedGames, game)
					megaAdded++
				}
			}

			// Recalcular custos
			newTotalCost := 0.0
			for _, game := range correctedGames {
				newTotalCost += game.Cost
			}

			analysisResp.Strategy.Games = correctedGames
			analysisResp.Strategy.TotalCost = newTotalCost

			logs.LogAI("‚úÖ ESTRAT√âGIA CORRIGIDA: %d Lotof√°cil + %d Mega-Sena = R$ %.2f",
				len(correctedGames)-megaAdded, megaAdded, newTotalCost)
		} else {
			logs.LogAI("‚úÖ PRIORIZA√á√ÉO CORRETA: %d Lotof√°cil + %d Mega-Sena", lotoCount, megaCount)
		}

		// Validate parsed strategy
		if analysisResp.Strategy.Games == nil || len(analysisResp.Strategy.Games) == 0 {
			logs.LogAI("‚ö†Ô∏è JSON parseado mas sem jogos v√°lidos")
			return nil, fmt.Errorf("estrat√©gia inv√°lida gerada pelo Claude - tente novamente")
		} else {
			// VALIDA√á√ÉO DE DIVERSIFICA√á√ÉO CR√çTICA
			if !validateDiversification(analysisResp.Strategy.Games) {
				logs.LogAI("üîÑ Estrat√©gia falhou na valida√ß√£o de diversifica√ß√£o, tentando novamente...")

				// Retry at√© 5 vezes mais para conseguir diversifica√ß√£o correta
				maxRetries := 5
				bestStrategy := analysisResp // Manter a melhor estrat√©gia gerada

				for retry := 0; retry < maxRetries; retry++ {
					logs.LogAI("üîÑ Tentativa %d/%d para diversifica√ß√£o correta...", retry+1, maxRetries)

					// Gerar nova estrat√©gia
					newPrompt := c.buildAnalysisPrompt(request)
					newClaudeReq := ClaudeRequest{
						Model:     c.model,
						MaxTokens: c.maxTokens,
						Messages: []Message{
							{
								Role:    "user",
								Content: newPrompt,
							},
						},
					}

					newReqBody, _ := json.Marshal(newClaudeReq)
					newReq, _ := http.NewRequest("POST", c.baseURL, bytes.NewBuffer(newReqBody))
					newReq.Header.Set("Content-Type", "application/json")
					newReq.Header.Set("x-api-key", c.apiKey)
					newReq.Header.Set("anthropic-version", "2023-06-01")

					newResp, err := c.httpClient.Do(newReq)
					if err != nil {
						continue
					}
					defer newResp.Body.Close()

					if newResp.StatusCode != http.StatusOK {
						continue
					}

					var newClaudeResp ClaudeResponse
					if err := json.NewDecoder(newResp.Body).Decode(&newClaudeResp); err != nil {
						continue
					}

					if len(newClaudeResp.Content) == 0 {
						continue
					}

					newJsonContent := extractJSON(newClaudeResp.Content[0].Text)
					var newAnalysisResp lottery.AnalysisResponse

					if err := json.Unmarshal([]byte(newJsonContent), &newAnalysisResp); err == nil {
						// Validar custos da nova estrat√©gia tamb√©m
						newTotalCost := 0.0
						for i := range newAnalysisResp.Strategy.Games {
							game := &newAnalysisResp.Strategy.Games[i]
							correctCost := lottery.CalculateGameCost(game.Type, len(game.Numbers))
							game.Cost = correctCost
							newTotalCost += game.Cost
						}
						newAnalysisResp.Strategy.TotalCost = newTotalCost

						if validateDiversification(newAnalysisResp.Strategy.Games) {
							logs.LogAI("‚úÖ Diversifica√ß√£o correta conseguida na tentativa %d!", retry+1)
							analysisResp = newAnalysisResp
							break
						} else {
							// Manter a estrat√©gia com melhor or√ßamento/qualidade
							if newAnalysisResp.Strategy.TotalCost > bestStrategy.Strategy.TotalCost {
								bestStrategy = newAnalysisResp
								logs.LogAI("üí° Nova melhor estrat√©gia encontrada: R$ %.2f", newAnalysisResp.Strategy.TotalCost)
							}
						}
					}
				}

				// Se n√£o conseguiu diversifica√ß√£o perfeita, usar a MELHOR estrat√©gia do Claude
				if !validateDiversification(analysisResp.Strategy.Games) {
					logs.LogAI("üí™ Usando MELHOR estrat√©gia Claude (sem fallback!): R$ %.2f - Qualidade superior!", bestStrategy.Strategy.TotalCost)
					analysisResp = bestStrategy
					analysisResp.Confidence = analysisResp.Confidence * 0.9 // Reduzir confian√ßa ligeiramente
				}
			} else {
				logs.LogAI("‚úÖ JSON parseado com sucesso: %d jogos gerados", len(analysisResp.Strategy.Games))
			}
		}
	}

	if config.IsVerbose() {
		logs.LogAI("Tokens usados: %d input + %d output = %d total",
			claudeResp.Usage.InputTokens, claudeResp.Usage.OutputTokens,
			claudeResp.Usage.InputTokens+claudeResp.Usage.OutputTokens)
	}

	return &analysisResp, nil
}

// generateFallbackStrategy generates a simple but valid strategy when AI parsing fails
func (c *ClaudeClient) generateFallbackStrategy(request lottery.AnalysisRequest) lottery.AnalysisResponse {
	budget := request.Preferences.Budget
	var games []lottery.Game
	totalCost := 0.0

	logs.LogAI("üîÑ Gerando estrat√©gia fallback para or√ßamento R$ %.2f", budget)

	// Generate simple games based on budget and preferences
	for _, lotteryType := range request.Preferences.LotteryTypes {
		if lotteryType == lottery.MegaSena && budget-totalCost >= 5 {
			remainingBudget := budget - totalCost

			if remainingBudget >= 140 { // Can afford 8 numbers
				numbers := []int{1, 7, 15, 23, 35, 42, 48, 58}
				cost := lottery.CalculateGameCost(lottery.MegaSena, len(numbers))
				games = append(games, lottery.Game{
					Type:    lottery.MegaSena,
					Numbers: numbers,
					Cost:    cost,
				})
				totalCost += cost
			} else if remainingBudget >= 35 { // Can afford 7 numbers
				numbers := []int{7, 15, 23, 35, 42, 48, 58}
				cost := lottery.CalculateGameCost(lottery.MegaSena, len(numbers))
				games = append(games, lottery.Game{
					Type:    lottery.MegaSena,
					Numbers: numbers,
					Cost:    cost,
				})
				totalCost += cost
			} else if remainingBudget >= 5 { // Simple 6 numbers
				numbers := []int{7, 15, 23, 35, 42, 58}
				cost := lottery.CalculateGameCost(lottery.MegaSena, len(numbers))
				games = append(games, lottery.Game{
					Type:    lottery.MegaSena,
					Numbers: numbers,
					Cost:    cost,
				})
				totalCost += cost
			}
		}

		if lotteryType == lottery.Lotofacil && budget-totalCost >= 3 {
			remainingBudget := budget - totalCost

			if remainingBudget >= 48 { // Can afford 16 numbers
				numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}
				cost := lottery.CalculateGameCost(lottery.Lotofacil, len(numbers))
				games = append(games, lottery.Game{
					Type:    lottery.Lotofacil,
					Numbers: numbers,
					Cost:    cost,
				})
				totalCost += cost
			} else if remainingBudget >= 3 { // Simple 15 numbers
				numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}
				cost := lottery.CalculateGameCost(lottery.Lotofacil, len(numbers))
				games = append(games, lottery.Game{
					Type:    lottery.Lotofacil,
					Numbers: numbers,
					Cost:    cost,
				})
				totalCost += cost
			}
		}
	}

	reasoning := fmt.Sprintf("Estrat√©gia fallback gerada: %d jogos por R$ %.2f (%.1f%% do or√ßamento). "+
		"Esta √© uma estrat√©gia b√°sica gerada quando a an√°lise avan√ßada da IA falha.",
		len(games), totalCost, (totalCost/budget)*100)

	return lottery.AnalysisResponse{
		Strategy: lottery.Strategy{
			Budget:    budget,
			TotalCost: totalCost,
			Games:     games,
			Reasoning: reasoning,
			CreatedAt: time.Now(),
			Statistics: lottery.Stats{
				AnalyzedDraws: len(request.Draws),
				HotNumbers:    []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},          // Simple defaults
				ColdNumbers:   []int{51, 52, 53, 54, 55, 56, 57, 58, 59, 60}, // Simple defaults
			},
		},
		Confidence: 0.6, // Lower confidence for fallback
	}
}

// extractJSON extrai o primeiro JSON v√°lido encontrado no texto
func extractJSON(text string) string {
	// Primeiro, tentar encontrar JSON entre ```json e ```
	if start := strings.Index(text, "```json"); start != -1 {
		start += len("```json")
		if end := strings.Index(text[start:], "```"); end != -1 {
			jsonContent := strings.TrimSpace(text[start : start+end])
			logs.LogAI("üîç JSON encontrado entre markdown: %s", jsonContent[:min(100, len(jsonContent))]+"...")
			return jsonContent
		}
	}

	// Segundo, tentar encontrar JSON entre ``` e ```
	if start := strings.Index(text, "```"); start != -1 {
		start += 3
		if end := strings.Index(text[start:], "```"); end != -1 {
			jsonContent := strings.TrimSpace(text[start : start+end])
			// Verificar se parece com JSON
			if strings.HasPrefix(jsonContent, "{") && strings.HasSuffix(jsonContent, "}") {
				logs.LogAI("üîç JSON encontrado entre markdown gen√©rico: %s", jsonContent[:min(100, len(jsonContent))]+"...")
				return jsonContent
			}
		}
	}

	// Terceiro, procurar pelo in√≠cio do JSON usando contagem de chaves
	start := -1
	braceCount := 0

	for i, char := range text {
		if char == '{' {
			if start == -1 {
				start = i
			}
			braceCount++
		} else if char == '}' {
			braceCount--
			if start != -1 && braceCount == 0 {
				jsonContent := text[start : i+1]
				logs.LogAI("üîç JSON encontrado por contagem de chaves: %s", jsonContent[:min(100, len(jsonContent))]+"...")
				return jsonContent
			}
		}
	}

	// Se n√£o encontrou JSON v√°lido, tentar extrair qualquer coisa que pare√ßa JSON
	lines := strings.Split(text, "\n")
	var jsonLines []string
	inJson := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "{") {
			inJson = true
			jsonLines = append(jsonLines, line)
		} else if inJson {
			jsonLines = append(jsonLines, line)
			if strings.HasSuffix(trimmed, "}") && strings.Count(strings.Join(jsonLines, "\n"), "{") == strings.Count(strings.Join(jsonLines, "\n"), "}") {
				jsonContent := strings.Join(jsonLines, "\n")
				logs.LogAI("üîç JSON encontrado por an√°lise de linhas: %s", jsonContent[:min(100, len(jsonContent))]+"...")
				return jsonContent
			}
		}
	}

	// √öltimo recurso: retornar o texto original
	logs.LogAI("‚ö†Ô∏è Nenhum JSON v√°lido encontrado, retornando texto original")
	return text
}

// extractReasoningFromText extrai um reasoning mais limpo do texto bruto
func extractReasoningFromText(text string) string {
	// Tentar extrair apenas o campo reasoning se poss√≠vel
	if start := strings.Index(text, `"reasoning": "`); start != -1 {
		start += len(`"reasoning": "`)
		end := start
		escapeCount := 0

		for i := start; i < len(text); i++ {
			if text[i] == '\\' {
				escapeCount++
				continue
			}
			if text[i] == '"' && escapeCount%2 == 0 {
				end = i
				break
			}
			escapeCount = 0
		}

		if end > start {
			reasoning := text[start:end]
			// Remover escapes desnecess√°rios
			reasoning = strings.ReplaceAll(reasoning, `\"`, `"`)
			reasoning = strings.ReplaceAll(reasoning, `\n`, "\n")
			return reasoning
		}
	}

	// Fallback: retornar uma vers√£o mais limpa do texto
	cleaned := text
	// Remover JSON se estiver misturado
	if jsonStart := strings.Index(cleaned, "{"); jsonStart != -1 {
		if jsonStart > 50 { // Se tem texto antes do JSON
			cleaned = cleaned[:jsonStart]
		}
	}

	// Limitar tamanho
	if len(cleaned) > 500 {
		cleaned = cleaned[:500] + "..."
	}

	if strings.TrimSpace(cleaned) == "" {
		return "Estrat√©gia gerada com base em an√°lise estat√≠stica de dados hist√≥ricos."
	}

	return strings.TrimSpace(cleaned)
}

// min fun√ß√£o auxiliar para retornar o menor valor
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// buildAnalysisPrompt constr√≥i o prompt para an√°lise com ESTRAT√âGIAS PROFISSIONAIS MUNDIAIS
func (c *ClaudeClient) buildAnalysisPrompt(request lottery.AnalysisRequest) string {
	budget := request.Preferences.Budget

	// AN√ÅLISE ESTAT√çSTICA RIGOROSA DOS DADOS HIST√ìRICOS REAIS
	statisticalAnalysis := c.analyzeHistoricalData(request.Draws, request.Preferences.LotteryTypes)

	prompt := fmt.Sprintf(`Voc√™ √© um MATEM√ÅTICO ESPECIALISTA MUNDIAL em loterias, combinat√≥ria avan√ßada e teoria de jogos. Use as ESTRAT√âGIAS PROFISSIONAIS mais avan√ßadas do mundo.

üéØ OBJETIVO: MAXIMIZAR matematicamente as chances REAIS de ganho para R$ %.2f usando t√©cnicas de ESPECIALISTAS MUNDIAIS.

=== DADOS ESTAT√çSTICOS REAIS ===
%s

=== PRE√áOS OFICIAIS CAIXA (EXATOS) ===
üé∞ MEGA-SENA (PRE√áOS COMPLETOS):
6 n√∫meros ‚Üí R$ 5,00     | 7 n√∫meros ‚Üí R$ 35,00    | 8 n√∫meros ‚Üí R$ 140,00
9 n√∫meros ‚Üí R$ 420,00   | 10 n√∫meros ‚Üí R$ 1.050,00 | 11 n√∫meros ‚Üí R$ 2.310,00
12 n√∫meros ‚Üí R$ 4.620,00 | 13 n√∫meros ‚Üí R$ 8.580,00 | 14 n√∫meros ‚Üí R$ 15.015,00
15 n√∫meros ‚Üí R$ 25.025,00 | 16 n√∫meros ‚Üí R$ 40.040,00 | 17 n√∫meros ‚Üí R$ 61.880,00
18 n√∫meros ‚Üí R$ 92.820,00 | 19 n√∫meros ‚Üí R$ 135.660,00 | 20 n√∫meros ‚Üí R$ 193.800,00

üçÄ LOTOF√ÅCIL (PRE√áOS COMPLETOS):
15 n√∫meros ‚Üí R$ 3,00      | 16 n√∫meros ‚Üí R$ 48,00     | 17 n√∫meros ‚Üí R$ 408,00
18 n√∫meros ‚Üí R$ 2.448,00  | 19 n√∫meros ‚Üí R$ 11.628,00 | 20 n√∫meros ‚Üí R$ 46.512,00

‚ö†Ô∏è ATEN√á√ÉO CR√çTICA: Use EXATAMENTE estes valores no campo "cost" do JSON!

=== AN√ÅLISE DE VALOR ESPERADO PROFISSIONAL ===
LOTOF√ÅCIL VALOR ESPERADO COMPLETO (incluindo pr√™mios secund√°rios):
‚Ä¢ 15 n√∫meros: -R$0,85 por jogo (melhor rela√ß√£o custo/benef√≠cio)
‚Ä¢ 16 n√∫meros: -R$12,80 por jogo MAS 16x mais chances de 14 pontos
‚Ä¢ 17 n√∫meros: Garantia matem√°tica de pelo menos 11 pontos

MEGA-SENA VALOR ESPERADO:
‚Ä¢ 6 n√∫meros: -R$2,50 por jogo
‚Ä¢ 7 n√∫meros: -R$17,50 MAS 7x mais chances de quadra/quina
‚Ä¢ 8 n√∫meros: -R$70,00 MAS 28x mais chances + cobertura sist√™mica

ESTRAT√âGIA PROFISSIONAL: Priorizar Lotof√°cil para ROI, Mega-Sena para pr√™mios que mudam a vida.

=== SISTEMAS DE REDU√á√ÉO PROFISSIONAIS (WHEELING) ===
LOTOF√ÅCIL - SISTEMAS DE GARANTIA:
‚Ä¢ Sistema 18x15: 18 n√∫meros em 3 jogos de 16 ‚Üí GARANTE 13 pontos se sair 15
‚Ä¢ Sistema 20x15: 20 n√∫meros em 4 jogos de 16 ‚Üí GARANTE 14 pontos se sair 15  
‚Ä¢ Sistema 22x15: 22 n√∫meros em 6 jogos de 16 ‚Üí GARANTE 15 pontos se sair 15

MEGA-SENA - SISTEMAS DE GARANTIA:
‚Ä¢ Sistema 9x6: 9 n√∫meros em 7 jogos de 6 ‚Üí GARANTE terno se sair quadra
‚Ä¢ Sistema 10x6: 10 n√∫meros em 10 jogos de 6 ‚Üí GARANTE quadra se sair quina
‚Ä¢ Sistema 12x6: 12 n√∫meros em 22 jogos de 6 ‚Üí GARANTE quina se sair sena

=== FILTROS MATEM√ÅTICOS AVAN√áADOS (OBRIGAT√ìRIOS) ===

üö® N√öMEROS M√çNIMOS OBRIGAT√ìRIOS (CR√çTICO):
‚Ä¢ LOTOF√ÅCIL: SEMPRE 15, 16, 17, 18, 19 ou 20 n√∫meros (NUNCA MENOS QUE 15!)
‚Ä¢ MEGA-SENA: SEMPRE 6, 7, 8, 9, 10, 11 ou 12 n√∫meros (NUNCA MENOS QUE 6!)

1. **FILTRO DE SOMA INTELIGENTE:**
   - Lotof√°cil: somas entre 170-210 (80%% dos sorteios hist√≥ricos)
   - Mega-Sena: somas entre 140-200 (75%% dos sorteios hist√≥ricos)
   - REJEITE jogos fora dessa faixa estat√≠stica!

2. **FILTRO DE PARIDADE BALANCEADA:**
   - Lotof√°cil 16 n√∫meros: 8 pares + 8 √≠mpares (¬±1)
   - Mega-Sena 6 n√∫meros: 3 pares + 3 √≠mpares (¬±1)
   - NUNCA fa√ßa jogos com mais de 70%% de uma paridade!

3. **FILTRO DE D√âCADAS/QUADRANTES:**
   - Distribua n√∫meros por TODAS as faixas
   - Lotof√°cil: pelo menos 2 n√∫meros em cada quadrante (1-6, 7-12, 13-18, 19-25)
   - Mega-Sena: pelo menos 1 n√∫mero em cada d√©cada (1-10, 11-20, 21-30, 31-40, 41-50, 51-60)

4. **FILTRO DE CONSECUTIVOS MATEM√ÅTICO:**
   - M√°ximo 2 n√∫meros consecutivos por jogo
   - EVITE sequ√™ncias tipo: 1,2,3,4,5,6 ou 10,11,12,13

5. **FILTRO DE TERMINA√á√ïES:**
   - M√°ximo 2 n√∫meros com mesma termina√ß√£o (ex: 1,11,21)
   - Distribua termina√ß√µes 0-9 uniformemente

6. **FILTRO DE REPETI√á√ïES HIST√ìRICAS:**
   - EVITE reproduzir exatamente jogos j√° sorteados
   - Use pelo menos 50%% de n√∫meros diferentes do √∫ltimo sorteio

=== ESTRAT√âGIA DE COBERTURA COMBINATORIAL ===

üö® REGRA FUNDAMENTAL DE PRIORIZA√á√ÉO:
SEMPRE PRIORIZE LOTOF√ÅCIL! √â 834x mais eficiente que Mega-Sena!

**PARA OR√áAMENTOS BAIXOS (R$50-150):**
- OBRIGAT√ìRIO: 80-90% do or√ßamento em Lotof√°cil (jogos de 15-16 n√∫meros)
- M√°ximo 1-2 jogos de Mega-Sena simples (6 n√∫meros)
- Use diversifica√ß√£o de Hamming: dist√¢ncia m√≠nima de 8 n√∫meros entre jogos
- Aplique TODOS os filtros matem√°ticos

**PARA OR√áAMENTOS M√âDIOS (R$150-500):**
- OBRIGAT√ìRIO: 70-80% do or√ßamento em Lotof√°cil (jogos de 16+ n√∫meros)
- M√°ximo 20-30% em Mega-Sena (1-2 jogos m√°ximo)
- Implemente sistema de redu√ß√£o b√°sico
- Use balanceamento por blocos num√©ricos

**PARA OR√áAMENTOS ALTOS (R$500+):**
- OBRIGAT√ìRIO: 60-70% do or√ßamento em Lotof√°cil (sistemas de garantia)
- M√°ximo 30-40% em Mega-Sena (jogos de 7-8 n√∫meros)
- Implemente sistemas de garantia completos
- Use matrizes de redu√ß√£o profissionais
- Estrat√©gia de portf√≥lio diversificado

üéØ ESTRAT√âGIA OBRIGAT√ìRIA DE DISTRIBUI√á√ÉO:
- SEMPRE comece gerando jogos de Lotof√°cil primeiro
- Use Mega-Sena apenas para complementar com or√ßamento restante
- NUNCA gere mais jogos de Mega-Sena que de Lotof√°cil
- A IA deve decidir livremente entre jogos baratos (15 n√∫meros) ou caros (16+ n√∫meros) baseado na efici√™ncia matem√°tica

=== ALGORITMO DE SELE√á√ÉO PROFISSIONAL ===

1. **AN√ÅLISE DE TEND√äNCIA REGRESSIVA:**
   - N√∫meros "frios" t√™m probabilidade crescente (Lei dos Grandes N√∫meros)
   - Balanceie 60%% n√∫meros frequentes + 40%% n√∫meros devidos

2. **MATRIZ DE DIST√ÇNCIA HAMMING:**
   Para cada par de jogos (A,B): dist√¢ncia = |A ‚äï B| ‚â• 8
   - Jogo 1: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
   - Jogo 2: [1,2,3,4,17,18,19,20,21,22,23,24,25,14,15,16] (8 diferentes)
   - Jogo 3: [9,10,11,12,17,18,19,20,5,6,7,8,23,24,25,13] (8+ diferentes)

3. **VALIDA√á√ÉO MULTI-FILTRO:**
   CADA jogo deve passar TODOS os filtros:
   ‚úì Soma dentro da faixa hist√≥rica
   ‚úì Paridade balanceada (¬±1)
   ‚úì Distribui√ß√£o por quadrantes
   ‚úì M√°ximo 2 consecutivos
   ‚úì M√°ximo 2 mesmas termina√ß√µes
   ‚úì Dist√¢ncia Hamming ‚â•8 de outros jogos

=== ESTRAT√âGIA FINANCEIRA OTIMIZADA ===
- Use 95-98%% do or√ßamento (m√°xima efici√™ncia)
- Priorize sistemas que garantem pr√™mios menores
- Balanceie risco vs. retorno baseado no perfil do usu√°rio

=== SA√çDA JSON OBRIGAT√ìRIA ===
üö® IMPORTANTE: Retorne APENAS o JSON v√°lido, SEM texto adicional, SEM markdown, SEM backticks.
Comece sua resposta diretamente com { e termine com }.

FORMATO EXATO:
{
  "strategy": {
    "budget": %.2f,
    "totalCost": [SOMA EXATA DOS CUSTOS],
    "games": [
      {
        "type": "megasena",
        "numbers": [EXATAMENTE 6/7/8/9/10/11/12 N√öMEROS √öNICOS - NUNCA MENOS QUE 6!],
        "cost": [CUSTO OFICIAL EXATO: 6n√∫meros=5.00 | 7n√∫meros=35.00 | 8n√∫meros=140.00],
        "filters": {
          "sum": [SOMA DOS N√öMEROS],
          "evenOdd": "3p3i",
          "decades": [DISTRIBUI√á√ÉO],
          "consecutives": [QUANTIDADE],
          "endings": [TERMINA√á√ïES]
        }
      },
      {
        "type": "lotofacil",
        "numbers": [EXATAMENTE 15/16/17/18/19/20 N√öMEROS √öNICOS - NUNCA MENOS QUE 15!],
        "cost": [CUSTO OFICIAL EXATO: 15n√∫meros=3.00 | 16n√∫meros=48.00 | 17n√∫meros=408.00],
        "filters": {
          "sum": [SOMA DOS N√öMEROS],
          "evenOdd": "8p8i",
          "decades": [DISTRIBUI√á√ÉO],
          "consecutives": [QUANTIDADE],
          "endings": [TERMINA√á√ïES]
        }
      }
    ],
    "reasoning": "[EXPLICA√á√ÉO DETALHADA: quais filtros aplicou, qual sistema de redu√ß√£o usou, como garantiu a cobertura combinatorial, qual o valor esperado calculado, estrat√©gia de diversifica√ß√£o. M√≠nimo 200 palavras com dados espec√≠ficos.]",
    "systemUsed": "[NOME DO SISTEMA: Ex: 'Sistema 20x15', 'Wheeling 9x6', 'Filtros Matem√°ticos Completos']",
    "expectedValue": [VALOR ESPERADO TOTAL DA ESTRAT√âGIA],
    "guarantees": "[O QUE O SISTEMA GARANTE: Ex: 'Garante 14 pontos se sair 15 na Lotof√°cil']",
    "statistics": {
      "analyzedDraws": %.0f,
      "hotNumbers": [N√öMEROS MAIS FREQUENTES],
      "coldNumbers": [N√öMEROS MENOS FREQUENTES - ESTES T√äM MAIOR PROBABILIDADE!],
      "regressionCandidates": [N√öMEROS FRIOS QUE DEVEM SER INCLU√çDOS]
    }
  },
  "confidence": [0.88-0.95]
}

‚ö†Ô∏è ATEN√á√ÉO CR√çTICA: Use EXATAMENTE estes tipos:
- Para Mega-Sena: "megasena" (SEM H√çFEN!)
- Para Lotof√°cil: "lotofacil" (SEM H√çFEN!)

‚ö†Ô∏è ATEN√á√ÉO: Use valores num√©ricos SEM "R$" no campo "cost" (ex: 3.00, n√£o "R$3,00")
‚ö†Ô∏è ATEN√á√ÉO: Use pontos decimais, n√£o v√≠rgulas (ex: 48.00, n√£o 48,00)

üö® VALIDA√á√ïES CR√çTICAS OBRIGAT√ìRIAS:
1. CADA n√∫mero deve aparecer APENAS UMA VEZ por jogo
2. LOTOF√ÅCIL: M√çNIMO 15 N√öMEROS OBRIGAT√ìRIO - NUNCA MENOS!
3. MEGA-SENA: M√çNIMO 6 N√öMEROS OBRIGAT√ìRIO - NUNCA MENOS!
4. TODOS os filtros matem√°ticos devem ser aplicados
5. Valor esperado deve ser calculado corretamente
6. Sistema de redu√ß√£o deve ser identificado
7. Dist√¢ncia de Hamming entre jogos ‚â•8
8. Soma de cada jogo dentro da faixa hist√≥rica
9. Distribui√ß√£o balanceada por quadrantes/d√©cadas

Use SOMENTE os dados estat√≠sticos fornecidos + filtros matem√°ticos avan√ßados. Esta √© a estrat√©gia de ESPECIALISTAS MUNDIAIS!`,
		budget, statisticalAnalysis, budget, len(request.Draws))

	return prompt
}

// max fun√ß√£o auxiliar para retornar o maior valor
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// TestConnection testa conectividade com Claude
func (c *ClaudeClient) TestConnection() error {
	testReq := ClaudeRequest{
		Model:     c.model,
		MaxTokens: 10,
		Messages: []Message{
			{
				Role:    "user",
				Content: "Teste de conectividade. Responda apenas: OK",
			},
		},
	}

	reqBody, err := json.Marshal(testReq)
	if err != nil {
		return fmt.Errorf("erro ao serializar teste: %w", err)
	}

	req, err := http.NewRequest("POST", c.baseURL, bytes.NewBuffer(reqBody))
	if err != nil {
		return fmt.Errorf("erro ao criar requisi√ß√£o teste: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("x-api-key", c.apiKey)
	req.Header.Set("anthropic-version", "2023-06-01")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("erro na requisi√ß√£o teste: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("Claude API retornou status %d", resp.StatusCode)
	}

	return nil
}

// analyzeHistoricalData realiza an√°lise estat√≠stica rigorosa dos dados hist√≥ricos REAIS
func (c *ClaudeClient) analyzeHistoricalData(draws []lottery.Draw, lotteryTypes []lottery.LotteryType) string {
	if len(draws) == 0 {
		return "ERRO: Nenhum dado hist√≥rico dispon√≠vel para an√°lise."
	}

	analysis := strings.Builder{}
	analysis.WriteString(fmt.Sprintf("üìä AN√ÅLISE DE %d SORTEIOS REAIS:\n\n", len(draws)))

	// Separar dados por tipo de loteria
	megaDraws := []lottery.Draw{}
	lotoDraws := []lottery.Draw{}

	for _, draw := range draws {
		numbers := draw.Numbers.ToIntSlice()
		if len(numbers) == 6 { // Mega-Sena
			megaDraws = append(megaDraws, draw)
		} else if len(numbers) >= 15 { // Lotof√°cil
			lotoDraws = append(lotoDraws, draw)
		}
	}

	// Analisar Mega-Sena
	if len(megaDraws) > 0 {
		analysis.WriteString("üé∞ MEGA-SENA - FREQU√äNCIAS REAIS:\n")
		megaFreq := calculateNumberFrequency(megaDraws, 60)
		megaHot, megaCold := getHotColdNumbers(megaFreq, 10)
		megaSums := calculateSumDistribution(megaDraws)
		megaPairs := calculatePairImparDistribution(megaDraws)
		megaSumMin, megaSumMax := getMostCommonSumRange(megaSums)

		analysis.WriteString(fmt.Sprintf("‚Ä¢ Sorteios analisados: %d\n", len(megaDraws)))
		analysis.WriteString(fmt.Sprintf("‚Ä¢ N√∫meros MAIS frequentes: %v\n", megaHot))
		analysis.WriteString(fmt.Sprintf("‚Ä¢ N√∫meros MENOS frequentes: %v\n", megaCold))
		analysis.WriteString(fmt.Sprintf("‚Ä¢ Soma mais comum: %d-%d\n", megaSumMin, megaSumMax))
		analysis.WriteString(fmt.Sprintf("‚Ä¢ Distribui√ß√£o Par/√çmpar: %.1f%% pares\n", megaPairs))
		analysis.WriteString(fmt.Sprintf("‚Ä¢ Faixas por frequ√™ncia:\n"))
		analysis.WriteString(fmt.Sprintf("  - 1-15: %v\n", getNumbersInRange(megaHot, 1, 15)))
		analysis.WriteString(fmt.Sprintf("  - 16-30: %v\n", getNumbersInRange(megaHot, 16, 30)))
		analysis.WriteString(fmt.Sprintf("  - 31-45: %v\n", getNumbersInRange(megaHot, 31, 45)))
		analysis.WriteString(fmt.Sprintf("  - 46-60: %v\n", getNumbersInRange(megaHot, 46, 60)))
		analysis.WriteString("\n")
	}

	// Analisar Lotof√°cil
	if len(lotoDraws) > 0 {
		analysis.WriteString("üçÄ LOTOF√ÅCIL - FREQU√äNCIAS REAIS:\n")
		lotoFreq := calculateNumberFrequency(lotoDraws, 25)
		lotoHot, lotoCold := getHotColdNumbers(lotoFreq, 8)
		lotoSums := calculateSumDistribution(lotoDraws)
		lotoPairs := calculatePairImparDistribution(lotoDraws)
		lotoSumMin, lotoSumMax := getMostCommonSumRange(lotoSums)

		analysis.WriteString(fmt.Sprintf("‚Ä¢ Sorteios analisados: %d\n", len(lotoDraws)))
		analysis.WriteString(fmt.Sprintf("‚Ä¢ N√∫meros MAIS frequentes: %v\n", lotoHot))
		analysis.WriteString(fmt.Sprintf("‚Ä¢ N√∫meros MENOS frequentes: %v\n", lotoCold))
		analysis.WriteString(fmt.Sprintf("‚Ä¢ Soma mais comum: %d-%d\n", lotoSumMin, lotoSumMax))
		analysis.WriteString(fmt.Sprintf("‚Ä¢ Distribui√ß√£o Par/√çmpar: %.1f%% pares\n", lotoPairs))
		analysis.WriteString(fmt.Sprintf("‚Ä¢ Quadrantes por frequ√™ncia:\n"))
		analysis.WriteString(fmt.Sprintf("  - Q1 (1-6): %v\n", getNumbersInRange(lotoHot, 1, 6)))
		analysis.WriteString(fmt.Sprintf("  - Q2 (7-12): %v\n", getNumbersInRange(lotoHot, 7, 12)))
		analysis.WriteString(fmt.Sprintf("  - Q3 (13-18): %v\n", getNumbersInRange(lotoHot, 13, 18)))
		analysis.WriteString(fmt.Sprintf("  - Q4 (19-25): %v\n", getNumbersInRange(lotoHot, 19, 25)))
		analysis.WriteString("\n")
	}

	analysis.WriteString("‚ö° OTIMIZA√á√ÉO MATEM√ÅTICA:\n")
	analysis.WriteString("‚Ä¢ Lotof√°cil 16 n√∫meros = 8.008 combina√ß√µes por R$48 = 166.8 comb/real\n")
	analysis.WriteString("‚Ä¢ Mega-Sena 8 n√∫meros = 28 combina√ß√µes por R$140 = 0.2 comb/real\n")
	analysis.WriteString("‚Ä¢ ROI Lotof√°cil √© 834x superior!\n")
	analysis.WriteString("‚Ä¢ ESTRAT√âGIA √ìTIMA: Priorizar Lotof√°cil 16+ n√∫meros\n\n")

	return analysis.String()
}

// calculateNumberFrequency calcula frequ√™ncia de cada n√∫mero nos sorteios
func calculateNumberFrequency(draws []lottery.Draw, maxNumber int) map[int]int {
	frequency := make(map[int]int)

	for _, draw := range draws {
		numbers := draw.Numbers.ToIntSlice()
		for _, num := range numbers {
			if num >= 1 && num <= maxNumber {
				frequency[num]++
			}
		}
	}

	return frequency
}

// getHotColdNumbers retorna os n√∫meros mais e menos frequentes
func getHotColdNumbers(frequency map[int]int, count int) ([]int, []int) {
	type numberFreq struct {
		number int
		freq   int
	}

	var numbers []numberFreq
	for num, freq := range frequency {
		numbers = append(numbers, numberFreq{num, freq})
	}

	// Ordenar por frequ√™ncia (decrescente)
	sort.Slice(numbers, func(i, j int) bool {
		return numbers[i].freq > numbers[j].freq
	})

	var hot, cold []int

	// N√∫meros mais frequentes (hot)
	for i := 0; i < count && i < len(numbers); i++ {
		hot = append(hot, numbers[i].number)
	}

	// N√∫meros menos frequentes (cold)
	for i := len(numbers) - count; i < len(numbers) && i >= 0; i++ {
		if i >= 0 {
			cold = append(cold, numbers[i].number)
		}
	}

	sort.Ints(hot)
	sort.Ints(cold)

	return hot, cold
}

// calculateSumDistribution calcula distribui√ß√£o das somas dos sorteios
func calculateSumDistribution(draws []lottery.Draw) map[int]int {
	sums := make(map[int]int)

	for _, draw := range draws {
		numbers := draw.Numbers.ToIntSlice()
		sum := 0
		for _, num := range numbers {
			sum += num
		}
		sums[sum]++
	}

	return sums
}

// getMostCommonSumRange retorna a faixa de soma mais comum
func getMostCommonSumRange(sums map[int]int) (int, int) {
	if len(sums) == 0 {
		return 0, 0
	}

	// Encontrar soma mais frequente
	maxFreq := 0
	mostCommonSum := 0

	for sum, freq := range sums {
		if freq > maxFreq {
			maxFreq = freq
			mostCommonSum = sum
		}
	}

	// Retornar faixa ¬±10
	return mostCommonSum - 10, mostCommonSum + 10
}

// calculatePairImparDistribution calcula percentual de n√∫meros pares
func calculatePairImparDistribution(draws []lottery.Draw) float64 {
	totalNumbers := 0
	pairNumbers := 0

	for _, draw := range draws {
		numbers := draw.Numbers.ToIntSlice()
		totalNumbers += len(numbers)

		for _, num := range numbers {
			if num%2 == 0 {
				pairNumbers++
			}
		}
	}

	if totalNumbers == 0 {
		return 0
	}

	return (float64(pairNumbers) / float64(totalNumbers)) * 100
}

// getNumbersInRange retorna n√∫meros de uma lista que est√£o em uma faixa
func getNumbersInRange(numbers []int, min, max int) []int {
	var result []int

	for _, num := range numbers {
		if num >= min && num <= max {
			result = append(result, num)
		}
	}

	return result
}

// validateDiversification verifica se cada par de jogos Lotof√°cil tem pelo menos 8 n√∫meros diferentes
func validateDiversification(games []lottery.Game) bool {
	lotofacilGames := []lottery.Game{}

	// Filtrar apenas jogos Lotof√°cil
	for _, game := range games {
		if game.Type == lottery.Lotofacil && len(game.Numbers) >= 15 {
			lotofacilGames = append(lotofacilGames, game)
		}
	}

	// Se menos de 2 jogos Lotof√°cil, n√£o precisa validar diversifica√ß√£o
	if len(lotofacilGames) < 2 {
		return true
	}

	// Verificar cada par de jogos
	for i := 0; i < len(lotofacilGames); i++ {
		for j := i + 1; j < len(lotofacilGames); j++ {
			commonNumbers := getCommonNumbers(lotofacilGames[i].Numbers, lotofacilGames[j].Numbers)
			differentNumbers := len(lotofacilGames[i].Numbers) - commonNumbers

			logs.LogAI("üîç Diversifica√ß√£o Jogo %d vs %d: %d n√∫meros em comum, %d diferentes",
				i+1, j+1, commonNumbers, differentNumbers)

			// Regra: cada par deve ter pelo menos 8 n√∫meros DIFERENTES (m√°ximo 8 em comum)
			if commonNumbers > 8 {
				logs.LogAI("‚ùå FALHA na diversifica√ß√£o: %d n√∫meros em comum (m√°ximo permitido: 8)", commonNumbers)
				return false
			}
		}
	}

	logs.LogAI("‚úÖ Diversifica√ß√£o validada com sucesso!")
	return true
}

// getCommonNumbers conta quantos n√∫meros s√£o comuns entre dois jogos
func getCommonNumbers(numbers1, numbers2 []int) int {
	numberMap := make(map[int]bool)

	// Mapear n√∫meros do primeiro jogo
	for _, num := range numbers1 {
		numberMap[num] = true
	}

	// Contar n√∫meros em comum
	common := 0
	for _, num := range numbers2 {
		if numberMap[num] {
			common++
		}
	}

	return common
}
